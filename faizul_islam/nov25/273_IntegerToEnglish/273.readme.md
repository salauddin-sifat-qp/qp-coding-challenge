# Integer to English Words - Solution Strategy

## Problem Overview

Convert a non-negative integer to its English words representation. The challenge involves handling various number scales (billions, millions, thousands) and special cases for numbers under 100.

## Solution Strategy

### Core Approach: Greedy Decomposition with Recursion

The algorithm uses a **greedy approach** combined with **recursion** to break down large numbers into their constituent parts, processing from largest to smallest denominations.

### Key Components

#### 1. Position Mapping

Create a comprehensive mapping of numbers to their English representations, ordered from largest to smallest:

```typescript
const positionMap: { [key: number]: string } = {
  1000000000: "Billion",
  1000000: "Million",
  1000: "Thousand",
  100: "Hundred",
  // Special handling for numbers 10-99
  90: "Ninety", 80: "Eighty", ..., 20: "Twenty",
  // Direct mapping for 1-19
  19: "Nineteen", 18: "Eighteen", ..., 1: "One"
};
```

#### 2. Three-Tier Processing Logic

**Source:** [273.ts](./273.ts)

The algorithm handles numbers in three distinct categories:

1. **Large Scale Numbers (≥100)**: Use recursion
2. **Tens (20-99)**: Direct tens mapping + remainder
3. **Teens & Singles (1-19)**: Direct mapping

## Algorithm Walkthrough

### Step-by-Step Process

1. **Initialize**: Start with empty result string
2. **Iterate**: Process denominators from largest to smallest
3. **Categorize**: Apply different logic based on number range
4. **Recursive**: For large numbers, recursively convert the quotient
5. **Accumulate**: Build the final string representation

### Example: Converting 1,234,567

| Step | Number  | Denomination      | Action         | Result So Far                                  |
| ---- | ------- | ----------------- | -------------- | ---------------------------------------------- |
| 1    | 1234567 | 1000000 (Million) | 1 × Million    | "One Million"                                  |
| 2    | 234567  | 1000 (Thousand)   | 234 × Thousand | "One Million Two Hundred Thirty Four Thousand" |
| 3    | 567     | 100 (Hundred)     | 5 × Hundred    | "... Five Hundred"                             |
| 4    | 67      | 60 (Sixty)        | Direct mapping | "... Sixty"                                    |
| 5    | 7       | 7 (Seven)         | Direct mapping | "... Seven"                                    |

**Final Result**: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

## Implementation Details

```typescript
function numberToWords(num: number): string {
  if (num === 0) return "Zero";

  let numericText = "";

  // Process each denomination from largest to smallest
  for (const key of Object.keys(positionMap)
    .map(Number)
    .sort((a, b) => b - a)) {
    while (num >= key) {
      // Case 1: Tens (20-99) - Special handling
      if (num < 100 && num >= 20) {
        const tens = Math.floor(num / 10) * 10;
        num -= tens;
        numericText += positionMap[tens] + " ";
        continue;
      }
      // Case 2: Teens & Singles (1-19) - Direct mapping
      else if (num < 20 && num > 0) {
        numericText += positionMap[num] + " ";
        num = 0;
        continue;
      }
      // Case 3: Large numbers (≥100) - Recursive approach
      else {
        const count = Math.floor(num / key);
        const countInWords = numberToWords(count); // Recursion
        const amountToSubtract = count * key;
        num -= amountToSubtract;
        numericText += countInWords + " " + positionMap[key] + " ";
      }
    }
  }

  return numericText.trim();
}
```

## Special Cases Handled

### 1. Numbers 20-99 (Tens)

- **Logic**: Extract tens digit, map directly, process remainder
- **Example**: 67 → "Sixty" + process(7) → "Sixty Seven"

### 2. Numbers 1-19 (Teens & Singles)

- **Logic**: Direct mapping from positionMap
- **Example**: 13 → "Thirteen" (not "Ten Three")

### 3. Large Scale Numbers (≥100)

- **Logic**: Recursive decomposition
- **Example**: 1234 → numberToWords(1) + "Thousand" + process(234)

### 4. Edge Cases

- **Zero**: Returns "Zero" immediately
- **Trailing spaces**: Trimmed from final result

## Algorithm Characteristics

### Time Complexity: **O(log n)**

- Number of iterations proportional to number of digits
- Each denomination processed at most once
- Recursive calls reduce problem size significantly

### Space Complexity: **O(log n)**

- Recursion stack depth proportional to number scale
- Constant space for the position mapping
- String concatenation creates intermediate results

## Design Decisions

### Why This Approach Works

1. **Greedy Strategy**: Always use the largest possible denomination
2. **Recursive Decomposition**: Handles complex number structures elegantly
3. **Special Case Handling**: Accounts for English language quirks (teens, tens)
4. **Sorted Processing**: Ensures proper order and completeness

### Alternative Approaches

1. **Iterative with Stack**: Replace recursion with explicit stack
2. **Template-Based**: Use string templates with placeholder substitution
3. **Digit-by-Digit**: Process individual digits with position awareness

## Edge Cases & Limitations

- **Range**: Supports 0 to 2,147,483,647 (32-bit signed integer)
- **Language**: English only (no internationalization)
- **Format**: Standard American English number naming
- **Precision**: Integer only (no decimals or fractions)

This solution elegantly combines mathematical decomposition with language-specific rules to convert any integer into its natural English representation.
